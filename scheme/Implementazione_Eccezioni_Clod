#lang racket

;################################
;# Gestione eccezioni in scheme #
;################################

;pila contenente i gestori delle eccezioni
(define *handlers* (list))

;pila contenente le eccezioni che vogliamo gestire
(define *exceptions* (list))

;una push per gli handlers
(define (push-handler proc)
  (set! *handlers* (cons proc *handlers*)))

;una pop per gli handlers
(define (pop-handler)
  (let ((h (car *handlers*)))
    (set! *handlers* (cdr *handlers*))
    h))

;una push per le eccezioni
(define (push-exception ex)
  (set! *exceptions* (cons ex *exceptions*)))

;una pop per le eccezioni
(define (pop-exception)
  (let ((e (car *exceptions*)))
    (set! *exceptions* (cdr *exceptions*))
    e))

;funzioni ausiliarie per le liste *exceptions* e *handlers* 
(define (more-handlers?) (pair? *handlers*))

(define (more-exceptions?) (pair? *exceptions*))

;Percorre lo stack delle eccezioni e se ne trova una corrispondente allora ritorna vero... in caso contrario falso
;Il metodo lavora in modo da mantenere allineati *handlers* e *exceptions*. Quando viene ritornato vero, dallo stack *handlers*
;non viene prelevato l'handler corrispondente, e le due pile risultaranno sfasate di uno fino a quando nel throw corrispondente
;non viene poppato ed eseguito
(define (same-exception? ex)
  ;DEBUG;(display "sono in same-exc: ") (display ex) (newline)
  (let ((top (pop-exception)))
    ;DEBUG;(display "sono e: ") (display e) (newline)
    (if (not (more-exceptions?))
        #F
        (if (string=? ex top)
            #T ; nel caso si ritorni true, non viene poppato l'handler che verrà successivamente preso e usato nel catch
            (begin
              (pop-handler)
              (same-exception? ex)))))) ;pop handler in quanto le due pile (handlers & exceptions) devono rimanere allineate
  
;_______________________________________________________________



;Procedura che lancia un'eccezione (UNA SOLA) ed eventualmente la gestisce
(define (throw e)
  (if (same-exception? e)
      ((pop-handler))   ;alla prima occorrenza della stessa eccezione trovata ne viene eseguito l'handler
      (error e))) ;se non ci sono eccezzioni dello stesso tipo in pila si avrà un errore

;Definizione del catch
(define-syntax catch
  (syntax-rules ()
    ((_ exception handler exp1 ...)
     (call/cc (lambda (exit)
                (push-exception exception)
                (push-handler (lambda ()
                                (exit handler)))
                (let ((res
                       (begin exp1 ...)))
                  (pop-handler)
                  (pop-exception)
                  res))))))

;Esempio di utilizzo
(define (foo x)
  (display x) (newline)
  (throw "eccezione_1"))

(catch "eccezione_1" (display "presa eccezione_1") 
  (display "prima di foo\n")
  (foo "CIAO!!\n")
  (display "dopo foo") ;non raggiungibile
  )
           
  
  
  
  
    
  
  
  
  
  
  

