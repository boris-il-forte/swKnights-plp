#lang racket

;################################
;# Gestione eccezioni in scheme #
;################################

;pila contenente i gestori delle eccezioni
(define *handlers* (list))

;pila contenente le eccezioni che vogliamo gestire
(define *exceptions* (list))

;una push per gli handlers
(define (push-handler proc)
  (set! *handlers* (cons proc *handlers*)))

;una pop per gli handlers
(define (pop-handler)
  (let ((h (car *handlers*)))
    (set! *handlers* (cdr *handlers*))
    h))

;una push per le eccezioni
(define (push-exception e)
  (set! *exceptions* (cons e *handlers*)))

;una pop per le eccezioni
(define (pop-exception)
  (let ((e (car *exceptions*)))
    (set! *exceptions* (cdr *exceptions*))
    e))

;funzioni ausiliarie per le liste *exceptions* e *handlers* 
(define (more-handlers?) (pair? *handlers*))

(define (more-exceptions?) (pair? *exceptions*))

;Percorre lo stack delle eccezioni e se ne trova una corrispondente allora ritorna vero... in caso contrario falso
;Il metodo lavora in modo da mantenere allineati *handlers* e *exceptions*. Quando viene ritornato vero, dallo stack *handlers*
;non viene prelevato l'handler corrispondente, e le due pile risultaranno sfasate di uno fino a quando nel throw corrispondente
;non viene poppato ed eseguito
(define (same-exception? ex)
  (if (not (more-exceptions?))
      #F
      (if (string=? ex (pop-exception))
          #T ; nel caso si ritorni true, non viene poppato l'handler che verrà successivamente preso e usato nel catch
          (begin
            (pop-handler)
            (same-exception? ex))))) ;pop handler in quanto le due pile (handlers & exceptions) devono rimanere allineate
  
;_______________________________________________________________



;Procedura che lancia un'eccezione (UNA SOLA) ed eventualmente la gestisce
(define (throw e)
  (if (same-exception? e)
      ((pop-handler))   ;alla prima occorrenza della stessa eccezione trovata ne viene eseguito l'handler
      (error e))) ;se non ci sono eccezzioni dello stesso tipo in pila si avrà un errore

;Definizione del catch
(define-syntax catch
  (syntax-rules ()
    ((_ exception handler exp1 ...)
     (call/cc (lambda (exit)
                (push-exception exception)
                (push-handler (lambda ()
                                (exit handler)))
                (let ((res
                       (begin exp1 ...)))
                  (pop-handler)
                  (pop-exception)
                  res))))))

;Esempio di utilizzo
(define (foo str)
  (display str)
  (throw "eccezione_2"))

(catch "eccezione_2"
  (begin
    (display "Ho catchato eccezione_2") #f)
  (catch "eccezione_1"
    (begin (display "Ho catchato eccezione_1") #f)
    (foo "HI\n")))
  
  
  
  
  
  

